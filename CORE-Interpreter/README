Name: Chenmeinian Guo

There're java source code file and compiled file. You're free to re-compile but I've saved the compiled file for you so it's easy to test.
### If you encountered any issues, please use <make> to clean and re-compile my codes

How to run:
1. subscribe to JDK-CURRENT
2. compile using <Make> command (I wrote javac so it would auto-compile)
3. run <java Main inputCodeFileName inputDataFileName> or the given scripts to test

Files: 
Core.java: provided by instructor; contains keywords/symbols
Scanner.java: Scanner wrote for project 1; contains all the codes I wrote
Correct: correct inputs provided by instructor
Error: error inputs provided by instructor
Main.java: run for testing; main function
(for convenience, I didn't write the .java/.class for the following files below)
Parser: parser; it contains many useful functions such as printTable(integer/record for testing), declare/assign functions, move/clear global/local variables, etc
ParserInterface: the general interface for all the grammer functions
Procedure: <procedure> ::= procedure ID is <decl-seq> begin <stmt-seq> end | procedure ID is begin <stmt-seq> end
DeclSeq: <decl-seq> ::= <decl > | <decl><decl-seq> | <function><decl-seq>
StmtSeq: <stmt-seq> ::= <stmt> | <stmt><stmt-seq> 
Decl: <decl> ::= <decl-integer> | <decl-record> 
DeclInteger: <decl-integer> ::= integer ID ;
DeclRecord: <decl-record> ::= record ID ;
DeclFunction: <function> ::= procedure ID ( <parameters> ) is <stmt-seq> end
Parameter: <parameters> ::= ID | ID , <parameters> 
Stmt: <stmt> ::= <assign> | <if> | <loop> | <out> | <decl> 
Call: <call> ::= begin ID ( <parameters> ) ;
AssignStmt: <assign> ::= id <index> := <expr> ; | id := new record [ <expr> ]; | id := record id; 
IfStmt: <if> ::= if <cond> then <stmt-seq> end | if <cond> then <stmt-seq> else <stmt-seq> end
LoopStmt: <out> ::= out ( <expr> ) ;
OutStmt: <out> ::= out ( <expr> ) ;
Index: <index> ::= [ <expr> ] | epsilon 
Cond: <cond> ::= <cmpr> | not <cond> | <cmpr> or <cond> | <cmpr> and <cond> 
Cmpr: <cmpr> ::= <expr> = <expr> | <expr> < <expr> 
Expr: <expr> ::= <term> | <term> + <expr> | <term> â€“ <expr>
Term: <term> ::= <factor> | <factor> * <term> | <factor> / <term>
Factor: <factor> ::= id | id [ <expr> ] | const | ( <expr> ) | in ( )



some thoughts/reviews:
I implemented the reference counting based on PerfectProject4. I added a new attribute to the static class Value called count. Each time we do operations like exiting scope of frame, we decrement or increment correspondingly. When the reference count reaches 0 or is created, we print the result "gb:?" to the console/system.  

## Without the call the program runs correctly
## No known bug

Thanks for grading my work!